<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Elaine blog</title>
	 <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
	<link rel="stylesheet" href="/blog/css/style.css">
	<link rel="stylesheet" href="/blog/css/highlight.css">
</head>
<body>
<header>
  <h1>Elaine <span>Blog<span></h1>
</header>   
<section class="container">
	<!-- 遍历后的文章 -->

<ul class="arc-list">
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/09/visibilitychange.html">[Javascript]visibilitychange</a></h2>
          <p class="arc-date">2017-09-04 </p>
          <p class="arc-con">[Javascript]visibilitychange

HTML5 API — 页面可见性改变(visibilitychange)事件在当前网页在可见和不可见之间变换的时候调用，这样便可适合在标签不可见的时候减少网络请求、服务器压力等。

目前页面可见性API有两个属性

document.hidden: Boolean值，表示当前页面可见还是不可见

document.visibilityState: 返回当前页面的可见状态

改变网页标题的文字

(function() {
    var OriginTitile = document.title, titleTime;
   ...<a href="/blog/learn/2017/09/visibilitychange.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/06/map.html">JS中的forEach、$.each、map方法</a></h2>
          <p class="arc-date">2017-06-22 </p>
          <p class="arc-con">JS中的forEach、$.each、map方法

forEach

forEach是ECMA5中Array新方法中最基本的一个，就是遍历，循环。

[1, 2 ,3, 4].forEach(alert);

等同于下面这个for循环

	var array = [1, 2, 3, 4];
 	for (var k = 0, length = array.length; k &lt; length; k++) {
		alert(array[k]);
	}

Array在ES5新增的方法中，参数都是function类型，默认有传参，forEach方法中的function回调支持3个参数，...<a href="/blog/learn/2017/06/map.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/06/clock.html">Clock</a></h2>
          <p class="arc-date">2017-06-22 </p>
          <p class="arc-con">HTML

&lt;div class="clock-bg"&gt;
	&lt;span id="wu"&gt;&lt;/span&gt;
	&lt;div class="clock"&gt;
		&lt;div class="hours-con"&gt; 
			&lt;div class="hours"&gt;&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="minutes-con"&gt;
			&lt;div class="minutes"&gt;&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="se...<a href="/blog/learn/2017/06/clock.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/js-map().html">JS自带的 map() 方法</a></h2>
          <p class="arc-date">2017-04-24 </p>
          <p class="arc-con">js 自带的 map() 方法

方法概述

map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。

例子

在字符串中使用map

在一个 String  上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：

	var map = Array.prototype.map
	var a = map.call("Hello World", function(x) { return x.charCodeAt(0); })
	// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 1...<a href="/blog/learn/2017/04/js-map().html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/queue.html">队列控制方法queue()/dequeue()/clearQueue()</a></h2>
          <p class="arc-date">2017-04-24 </p>
          <p class="arc-con">队列控制方法queue()/dequeue()/clearQueue()

jQuery核心中，有一组队列控制方法, 这组方法由queue()/dequeue()/clearQueue()三个方法组成，它对需要连续按序执行的函数的控制可以说是简明自如, 主要应用于animate ()方法，ajax以及其他要按时间顺序执行的事件中。

queue(name,[callback])


  当只传入一个参数时, 它返回并指向第一个匹配元素的队列(将是一个函数数组,队列名默认是fx);
  当有两个参数传入时, 第一个参数还是默认为fx的的队列名, 第二个参数又分两种情况, 当第二个参数是一个...<a href="/blog/learn/2017/04/queue.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/currentStyle.html">区别style、runtimeStyle、currentStyle、getComputedStyle</a></h2>
          <p class="arc-date">2017-04-24 </p>
          <p class="arc-con">区别style、runtimeStyle、currentStyle、getComputedStyle

在JavaScript中，通过document.getElementById(id).style.XXX就可以获取到XXX的值，但是这样做只能取到通过内嵌方式设置的样式值，即style属性里面设置的值。

style
只能获取或修改内嵌样式增改top、left等，IE里直接写数值，Firefox等要加”px”

语法：
document.getElementById(id).style.XXX

runtimeStyle

运行时的样式，如果与style的属性重叠，将覆盖style的属...<a href="/blog/learn/2017/04/currentStyle.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/arguments.html">Arguments</a></h2>
          <p class="arc-date">2017-04-24 </p>
          <p class="arc-con">Arguments

argeuments特性

1. 每个函数都有一个arguments属性，表示函数的实参集合，这里的实参是重点，就是执行函数时实际传入的参数的集合。

2. arguments不是数组而是一个对象，但它和数组很相似，所以通常称为类数组对象，以后看到类数组其实就表示arguments。

3. arguments有length属性，可以用arguments[length]显示调用。

在js中 不需要明确指出参数名，就能访问它们，例如：

function test() {
        var s = "";
        for (var i = 0; i &...<a href="/blog/learn/2017/04/arguments.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/regexp.html">正则表达式</a></h2>
          <p class="arc-date">2017-04-20 </p>
          <p class="arc-con">正则表达式

1. 定义正则表达式

通过构造函数

第一个参数为正则表达式的文本内容，第二个参数表示匹配g（全文查找），i（忽略大小写） ，m（多行查找）

var re = new RegExp();//RegExp是一个对象,和Aarray一样  
//但这样没有任何效果,需要将正则表达式的内容作为字符串传递进去  
re =new RegExp("a");//最简单的正则表达式,将匹配字母a  
re=new RegExp("a","i");//第二个参数,表示匹配时不分大小写  

通过//，也就是两个斜杠

2. 正则表达式对象的常用属性和方法


  test返回一个 Bo...<a href="/blog/learn/2017/04/regexp.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/04/event.html">事件冒泡和事件捕获</a></h2>
          <p class="arc-date">2017-04-20 </p>
          <p class="arc-con">
&lt;div id="outer"&gt;
    &lt;p id="inner"&gt;Click me!&lt;/p&gt;
&lt;/div&gt; 

上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念

1. 事件冒泡
事件冒泡就像鱼吐泡泡一样，从水下向水面走，也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。
因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是p -&gt; div -&gt...<a href="/blog/learn/2017/04/event.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/01/gitbook.html">gitbook的安装</a></h2>
          <p class="arc-date">2017-01-19 </p>
          <p class="arc-con">gitbook的安装

1. 执行$ npm install gitbook -g，但是会有报错



2. 根据提示执行npm uninstall -g gitbook和npm install -g gitbook-cli，如果是mac系统要加sudo

3. 执行gitbook -V就开始安装，注意是大写V



3. 再执行gitbook -V查看是否安装成功



4. 新建一个目录gitbook，执行初始化gitbook init，之后gitbook这个目录下会生成README.md和SUMMARY.md这两个文件



5. 编辑SUMMARY.md

SUMMARY.md就...<a href="/blog/learn/2017/01/gitbook.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/01/git-page.html">git page配置</a></h2>
          <p class="arc-date">2017-01-19 </p>
          <p class="arc-con">git page配置

1. 登录github，击右上角的“+”号，选择“New repository”菜单，创建仓库



2. 填写Repository name，必须符合规则username.github.io，勾选下面的”Initialize this repository with a README”



3.  进入username.github.io文件夹，选择Setting



4.  设置Github Pages，点击 source 中的本来的 None ，使其变成 master 分支，也就是作为部署github pages 的分支，然后点击 save


<a href="/blog/learn/2017/01/git-page.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/01/git-more-account.html">git 多账号配置</a></h2>
          <p class="arc-date">2017-01-19 </p>
          <p class="arc-con">git 多账号配置

1. 创建github对应的sshkey

ssh-keygen -t rsa -C email

2. 创建github对应的sshkey，命名为id_rsa_oschina，密码 123456



3. 访问的.ssh目录, 打开id_rsa_oschina.pub,copy SSh key 到github





4. 配置config文件


<a href="/blog/learn/2017/01/git-more-account.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/01/git-install.html">安装git</a></h2>
          <p class="arc-date">2017-01-19 </p>
          <p class="arc-con">安装git
windows安装

1. 下载git客户端

下载地址为：https://git-scm.com/download/mac

2. 打开安装包



3. git config 配置

git config --global user.name shining
git config --global user.email shining@achang.com 
git config --list



4. 生成SSH key

ssh-keygen -t rsa -C "shining@achang.com"



5. id_rsa.pub查看ssh key



ma...<a href="/blog/learn/2017/01/git-install.html" class="more">Read More</a></p>
        </li>
    
        <li>
          <h2 class="arc-title"><a href="/blog/learn/2017/01/flex-learn1.html">Flexbox学习之一</a></h2>
          <p class="arc-date">2017-01-19 </p>
          <p class="arc-con">Flexbox学习之一

xuxn.github.io布局想要实现左右1:2的布局，用到了flex:1 0 0和flex:2 0 0，这样的写法其实是Flexbox的3个属性，依次是flex-grow，flex-shrink，flex-basis，flex-basis是Flexbox项目的基准值，决定着其他两个属性。

1. flex-grow（扩展比例）

1.1 注意flex-grow值不依赖于其他项，容器里一个flex-grow为4的项不一定是另一个flex-grow为2的项的2倍。

1.2 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大


 ...<a href="/blog/learn/2017/01/flex-learn1.html" class="more">Read More</a></p>
        </li>
    
</ul>



<!-- 分页链接 -->
<!-- <div class="pagination">
  
    <span class="previous">Previous</span>
  
  <span class="page_number ">Page:  of </span>
  
    <span class="next ">Next</span>
  
</div>
 -->

 


</section>   
<footer>
	<p>Copyright &copy; 2017@Elaine Blog / All rights reserved.</p>
</footer>